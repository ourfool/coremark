# Coremark-jp

下記はCoreMarkベンチマークについての説明をSaginomiyaが邦訳したものです。正確な記述に関しては[folk元リポジトリの原文](https://github.com/eembc/coremark)をご参照ください。

# イントロダクション

CoreMarkベンチマークの主な目標は、プロセッサの基本機能をシンプルにテストする方法を提供することです。EEMBCの組み込みベンチマーク全般についてのより詳しい情報は、[www.eembc.org](www.eembc.org)を参照してください。

[CoreMark-PRO](https://www.github.com/eembc/coremark-pro)ベンチマークもGithub上に用意されています。これは一般的なアプリケーションから取得された比較的大きなデータセットと実行ループを利用する計算量の大きなベンチマークです。

# ビルドとベンチマーク実行

下記のようにコマンドをタイプすることで、ベンチマークのビルドと実行がおこなわれます。
~~~
$ make
~~~
結果は`run1.log`、`run2.log`として出力されます。CoreMarkのベンチマーキング結果は`run1.log`に記載されています。

## クロスコンパイル

ホストマシンと異なるマシン向けにクロスコンパイルするためには、

* `core_portme.mak`
* `core_portme.h`
* `core_portme.c`（場合に応じて）

を編集します。新たなプラットフォームへのポーティングのためには、まずはデフォルトのフォルダを下記のようなコマンドでコピーし
~~~
$ mkdir ${特定のプラットフォーム名} && cp linux/* ${特定のプラットフォーム名}
~~~
適切にファイルを編集したあとで、下記のように実行します。
~~~
$ make PORT_DIR=${特定のプラットフォーム名}
~~~

## Makeのターゲット一覧

`run`：デフォルトターゲット。`run1.log`と`run2.log`を生成します。
`run1.log`：性能パラメータと共に実行。`run1.log`を生成します。
`run2.log`：検証パラメータと共に実行。`run2.log`を生成します。
`run3.log`：プロファイル情報と共に実行。`run3.log`を生成します。
`compile`：ベンチマークを実行可能なかたちにコンパイルします。
`link`：ベンチマークを実行可能なかたちにリンクします。
`check`：MD5チェックサムを確認します。
`clean`：一時ファイルを削除します。

### Makeフラグ：`ITERATIONS`

デフォルトでは、ベンチマークは実行時間が10～100秒となるような回数実行されます。これを上書きするためには、`ITERATIONS=N`として明示的に実行回数を指定します。
~~~
$ make ITERATIONS=10
~~~
とすると10回実行されます。実行回数の指定は下記のような場合において推奨されます。

* シミュレータ上での実行
* 消費電力・エネルギー測定
* 実行時間の複数回測定機構が無い場合

最小実行時間について：**結果は10秒間以上実行した場合にのみ有効とみなされ提出可能です**

### Makeフラグ：`XCFLAGS`

フラグをコマンドラインから追加したい場合、`XCFLAGS`を使います。
~~~
$ make XCFLAGS="-g -DMULTITHREAD=4 -DUSE_FORK=1"
~~~

### Makeフラグ：`CORE_DEBUG`

CRC結果が不正でデバッグを行う場合に指定します。
~~~
$ make XCFLAGS="-DCORE_DEBUG=1"
~~~

### Makeフラグ：`REBUILD`

実行ファイルを強制的にリビルドします。

## Makeの無いシステムの場合

下記のファイル群をコンパイルします。
* `core_list_join.c`
* `core_main.c`
* `core_matrix.c`
* `core_state.c`
* `core_util.c`
* `PORT_DIR/core_portme.c`

コマンド例
~~~
$ gcc -O2 -o coremark.exe core_list_join.c core_main.c core_matrix.c core_state.c core_util.c simple/core_portme.c -DPERFORMANCE_RUN=1 -DITERATIONS=1000
$ ./coremark.exe > run1.log
~~~
上の例ではベンチマークが性能調査向けに1000回実行されるようコンパイルされます。出力は、`run1.log`にリダイレクトされます。

# 並列実行

並列実行のためには、`XCFLAGS=-DMULTITHREAD=N`と設定します。 ここでNは並列スレッド数です。いくつかの実装は複数コンテキストでの実行をサポートしています。独自実装を追加する場合には`core_portme.c`を編集します。
~~~
$ make XCFLAGS="-DMULTITHREAD=4 -DUSE_PTHREAD"
~~~
上のようなコマンドでは、POSIXスレッドAPIを用いて4コアで実行されるようにコンパイルがおこなわれます。
注釈: リンカが自動的に`pthread`ライブラリを追加しない場合、上記のコマンドではリンクが失敗します。もし、`undefined reference`というエラーが発生したら、`core_portme.mak`を自分の環境向けに修正し（例. `linux/core_portme.mak`）、`-lpthread`を`LFLAGS_END`パラメータに追加してください。

# ベンチマークの実行時パラメータ

CoreMarkの実行ファイルは下記のようなパラメータをとります (ただし`main()`のみが引数をとります):
1st - データ初期化のためのシード値。
2nd - データ初期化のためのシード値。
3rd - データ初期化のためのシード値。
4th - 実行回数 (デフォルト値は0、0を指定した場合は自動的に実行回数を算出)
5th - 内部で利用。 
6th - 内部で利用。 
7th - mallocを利用可能な環境のみ。入力データバッファの値を上書き。

makeによって実行した場合は、2つの異なるシード値で初期化されたCoremarkが実行されます。

## 代替パラメータ: 
`malloc`を利用しない場合やコマンドラインからのパラメータ指定がおこなえない場合、アルゴリズム向けのバッファサイズを`TOTAL_DATA_SIZE`を使ってコンパイラ経由で指定する必要があります。`TOTAL_DATA_SIZE`は標準的な実行においては2000 byte（デフォルト値）に指定します。異なる設定でテストをおこおこなう場合のコマンドは下記のようになります。

~~~
% make XCFLAGS="-DTOTAL_DATA_SIZE=6000 -DMAIN_HAS_NOARGC=1"
~~~

# リザルト提出

CoremarkのリザルトはWebから提出することができます。Webブラウザを開き、[提出ページ](https://www.eembc.org/coremark/submit.php)にアクセスします。アカウント登録後にスコア投稿が可能になります。

# ベンチマーク実行時のルール

実行時のルールを下記にまとめています。

## 要件
1. ベンチマークは少なくとも10秒間の実行が必要です.
2. すべての検証はシード値`0, 0, 0x66`、`0x3415, 0x3415, 0x66`、2000 byteのバッファサイズにおいて成功する必要があります。
    * コマンドラインでのメイン関数引数指定を利用しない場合:
~~~
	% make XCFLAGS="-DPERFORMANCE_RUN=1" REBUILD=1 run1.log
	% make XCFLAGS="-DVALIDATION_RUN=1" REBUILD=1 run2.log
~~~
3. プロファイルに基づく最適化をおこなう場合、そのプロファイルはシード値`8, 8, 8`と合計1200 byteのバッファサイズとする必要があります。
~~~
    % make XCFLAGS="-DTOTAL_DATA_SIZE=1200 -DPROFILE_RUN=1" REBUILD=1 run3.log
~~~
4. すべてのソースファイルは共通のフラグでコンパイルしてください。
5. すべてのデータ型サイズは下記のサイズと一致させてください。
	* `ee_u8` は符号なしの8-bitデータ型です。
	* `ee_s16` は符号付きの16-bitデータ型です。
	* `ee_u16` は符号なしの16-bitデータ型です。
	* `ee_s32` は符号付きの32-bitデータ型です。
	* `ee_u32` は符号なしの32-bitデータ型です。

## 許可されている変更

1. 実行回数の変更
2. ツールチェーンや、ビルド・ロード・実行オプションの変更
3. データメモリブロックを取得する方法の変更
5. シード値を取得する方法の変更
6. `core_portme.c`の変更
7. `core_portme.h`内の設定パラメータの変更
8. `core_portme.mak`の変更

## 禁止されている変更

1. `core_portme*`以外のソースファイルの変更 (`make check`でこのような変更が無いか検証することができます)

# 提出のルール

下記のようなフォーマットでデータシートを記入し、リザルトを提出します。

CoreMark 1.0 : N / C [/ P] [/ M]

N - 1秒あたりの実行回数（シード値は0, 0, 0x66、バッファサイズは2000）

C - コンパイラのバージョンとフラグ

P - データとコードの割り当て設定

* すべてのデータがRAMのヒープ領域に割り当てられる場合はこのパラメータは省略できます。
* CoreMark/MHzの報告時にはこのパラメータは省略しないでください。

M - 並列実行形式とコンテキスト数
* 並列実行がおこなわれていない場合にはこのパラメータは省略できます。

例:

~~~
CoreMark 1.0 : 128 / GCC 4.1.2 -O2 -fprofile-use / Heap in TCRAM / FORK:2 
~~~
or
~~~
CoreMark 1.0 : 1400 / GCC 3.4 -O4 
~~~

スケーリング結果を報告する場合、結果は下記のように報告してください。

CoreMark/MHz 1.0 : N / C / P [/ M]

P - スケーリング結果を報告する場合、メモリパラメータからメモリの周波数とコアの周波数の比がわかるようにしてください。
1. もしコアがキャッシュを持っており、キャッシュの動作周波数とコアの動作周波数が設定可能であるなら、そのことも含めて報告ください。
例:

~~~
CoreMark/MHz 1.0 : 1.47 / GCC 4.1.2 -O2 / DDR3(Heap) 30:1 Memory 1:1 Cache
~~~

# ログファイルフォーマット

ログファイルは下記のようなフォーマットになっています。

~~~
2K performance run parameters for coremark.	(実行タイプ)
CoreMark Size    	: 666					(バッファサイズ)
Total ticks			: 25875					(実行環境依存の値)
Total time (secs) 	: 25.875000				(実行時間)
Iterations/Sec 		: 3864.734300			(報告に用いる性能値)
Iterations			: 100000				(実行回数)
Compiler version	: GCC3.4.4				(コンパイラとバージョン)	
Compiler flags		: -O2					(コンパイラとリンカのフラグ)
Memory location		: Code in flash, data in on chip RAM
seedcrc				: 0xe9f5				(入力シード値の識別子)
[0]crclist			: 0xe714				(連結リスト演算部の検証)
[0]crcmatrix		: 0x1fd7				(行列演算部の検証)
[0]crcstate			: 0x8e3a				(ステートマシン演算部の検証)
[0]crcfinal			: 0x33ff				(実行回数依存の出力)
Correct operation validated. See README.md for run and reporting rules.  (*実行成功時のみ表示*)
CoreMark 1.0 : 6508.490622 / GCC3.4.4 -O2 / Heap 						  (*実行成功時のみ表示*)
~~~

# 動作原理

ここではCoremarkの目指すところとその実装とについて述べます。

## 容易に理解可能

* 少ないコード行数
* 意味を理解しやすい変数や関数の命名
* コードの各ブロック毎に10行以上のコメントを付与

## ポータビリティ

I/Oやタイミングの違いに対応するための薄い抽象化レイヤが提供されています。I/Oやタイミングに関連するすべてのことがこのレイヤを介して処理されます。

### コード/データサイズ

* x86マシン上のgccでコンパイルをおこない、すべてのサイズが要求を満たしていることを検証済。
* 動的なメモリ割り当てを使用している場合は、割り当てられたメモリの合計についても考慮。
* 再帰的な関数を避け、スタックの使用状況を把握。
* すべてのアルゴリズムでデータ参照元として同じメモリブロックを使用し、各アルゴリズムの前にデータを初期化しています。これにより、データの初期化は制限時間内に行われることになりますが、1回しか行われないため、結果へ与える影響はごくわずかです。

## 制御された出力

これは最も困難な目標かもしれません。コンパイラは常に改良を重ね、コードの解析能力を高めています。コンパイル時には計算できず、実行時に計算しなければならない仕事を作るためには、下記のような2つの仮定に頼ることになります。

* システム関数（time、scanfなど）やパラメータの中には、コンパイル時に計算できないものがあります。 ほとんどの場合、変数をvolatileにすることは、コンパイラがこの変数の値を読もうとするたびに強制的に読ませることを意味します。これは、コンパイル時に事前計算できない要素を入力値に入れ込むために使用されます。結果は入力に依存しているので、実行時に計算が必要になることがわかります。

* システム関数、I/O（scanfなど）、コマンドラインパラメータ、volatile変数のいずれかが制限時間部分の前で使用され、コンパイル時には得ることのできないデータを生成します。制御可能であり、コンパイラがコンパイル時に計算したり、除去したりできないものであればどんな方法でも問題ありませんが、例えば、clock()関数がコンパイラのスタブである場合は使用できません。値は出力としてレポートされるので、異なるマシン上でも検証が可能です。

* 組込みシステムの中には、コマンドラインパラメータを提供する機能を持たないものがあるため、コマンドラインパラメータに頼ることはできません。上記の3つの方法（時間ベース、scanf、コマンドラインパラメータ）はすべて実装され、コンパイラがコンパイル時に値を決定できない場合には3つとも有効です。

* 実行時に供給される実際の値は標準化されていることに注意してください。上記はランダムなデータを提供するために利用されるものではなく、単にコンパイル時に事前計算できない制御されたデータを提供することが目的です。

* 表示される結果は、実行中に有効でなければなりません。これは、計算が実行されたことを確認するために使用されます。

* 組込みシステムの中には「printf」などのI/O機能を提供していないものがあります。すべての入出力は薄い抽象化インターフェースを介して行われ、そうしたシステム上での実行を可能にします（例えば、JTAG経由で出力を行うなど）。

## 重要なアルゴリズム

### 連結リスト

下記のようなリンク構造が利用されます。

~~~
typedef struct list_data_s {
	ee_s16 data16;
	ee_s16 idx;
} list_data;

typedef struct list_head_s {
	struct list_head_s *next;
	struct list_data_s *info;
} list_head;
~~~

この構造は、データへのアクセスに間接性を持たせつつ、現実的であり、小～中規模のリストを扱う多くの組み込みアプリケーションで使用されています。

リスト自体は、初期化関数に渡されたメモリブロックで初期化されます。一般的には連結リストは新たなノードのためにmallocを使用しますが、組み込みアプリケーションではシステムコールのオーバーヘッドを避けるために配列やリストなどの小さなデータ構造のメモリを直接制御することがあり、このアプローチが現実的になります。

連結リストは、リストポインタの1/4がメモリ上のシーケンシャルな領域を指し、3/4がノンシーケンシャルに散らばるように初期化されます。これは、しばらくの間add/removeが起こって順序が乱され、その後、順次メモリの場所から追加が行われるような状態をエミュレートするためです。

ベンチマーク自体について:
- 複数の検索操作が行われます。これらの検索操作により、リスト全体を横断することがあります。各検索の結果は、出力の一部となります。
- リストは、data16の値に基づいてマージソートを使用してソートされ、リストの一部に対してdata16のCRCを順に導きます。このCRCが出力の一部となります。
- リストは、idxの値に基づいてマージソートで再度ソートされます。このソートにより、関数を終了する前にリストが最初の状態へと戻されることが保証され、関数を複数回繰り返しても同じ結果が得られます。リストの一部に対するdata16のCRCが再び計算され、出力の一部となります。

各セルの実際の`data16`は，コンパイル時には決定できない単一の16-bitの入力に基づく擬似ランダムな値です。また、CRCに使用されるリストの一部分も関数に渡され，実行時には決定できない入力に基づいて決定されます。

### 行列乗算

ここに示す非常にシンプルなアルゴリズムが、多くのより複雑なアルゴリズムの基礎になっています。タイトな内部ループは、多くの（コンパイラおよびハードウェアベースの）最適化の焦点となっており、したがって、組み込み処理にも関連しています。

利用可能なデータ空間は下記の3つに分類されます。
1. NxNの行列A
2. NxNの行列B
3. NxNの行列C

例. 2K byteの場合は3つの12x12行列（32-bitのデータ型を想定すると、12(len)*12(wid)*4(size)*3(num) =1728 bytes）

行列Aは、小さな値（上位3/4のビットがすべて0）で初期化されます。
行列Bは、中程度の値（上位半分のビットがすべて0）で初期化されます。
行列Cは、結果に使用されます。

ベンチマーク自体について:
- Aを定数倍してCに入力し、結果行列の各値の上位ビットを加算します。その結果が出力の一部となります。
- AにBのX列を乗じたものをCに入力し、結果行列の各値の上位ビットを加算します。その結果が出力の一部となります。
- AにBを乗じたものをCに入力し、結果行列の各値の上位ビットを加算します。その結果が出力の一部となります。

AとBの実際の値は、コンパイル時には得られない入力に基づいて決める必要があります。

### ステートマシン

この部分ではswitch文やif文を行使する必要があります。ここでは、小さなムーア型ステートマシンを使います。具体的には、文字列の入力を数字として認識し、形式に応じて分割するステートマシンとします。

ステートマシンは、「,」セパレータか入力の終わりに遭遇するまで、入力文字列を解析します。無効な数値が入力された場合は、ステートマシンは無効な状態を返し、有効な数値が入力された場合は、ステートマシンは数値の形式（int/float/scientific）を返します。

このコードは、現実的なタスクを実行し、十分小さく理解し易く、必要な機能を行使しています。組込みシステムで使われるもう一つの選択肢はミーリ型ステートマシンで、これはテーブルによって駆動されています。テーブルは、状態の数と遷移の複雑さを決定します。しかし、この方法では、主にロード/ストアや関数呼び出しのメカニズムがテストされ、分岐の処理はそれほど行われません。最終的な結果を分析した結果、プロセッサのロード/ストア機能が十分に行使されていないことが判明した場合には、ベンチマークに追加するのが良いでしょう（コードサイズが許す限り）。

入力として、形式が混在するコンマ区切りの値や、無効な入力でメモリブロックが初期化されます。

ベンチマーク自体について:
- すべての入力に対してステートマシンを起動し、最終的な状態と状態遷移をカウントする。すべての最終状態と遷移のCRCが出力の一部となります。
- 間隔を置いて入力を修正し（エラーを混入させる）、ステートマシン操作を繰り返す。
- 入力を元の形に修正する。

実際の入力は、コンパイル時には決定できないデータに基づいて初期化されなければなりません。また、入力を修正する間隔と実際の修正とについても、コンパイル時には決定できない入力に基づいて行われなければなりません。

# 検証

本リリースは下記のプラットフォームでテストされています。
* x86 cygwin and gcc 3.4 (Quad, dual and single core systems)
* x86 linux (Ubuntu/Fedora) and gcc (4.2/4.1) (Quad and single core systems)
* MIPS64 BE linux and gcc 3.4 16 cores system
* MIPS32 BE linux with CodeSourcery compiler 4.2-177 on Malta/Linux with a 1004K 3-core system
* PPC simulator with gcc 4.2.2 (No OS)
* PPC 64b BE linux (yellowdog) with gcc 3.4 and 4.1 (Dual core system)
* BF533 with VDSP50 
* Renesas R8C/H8 MCU with HEW 4.05
* NXP LPC1700 armcc v4.0.0.524
* NEC 78K with IAR v4.61
* ARM simulator with armcc v4

# メモリ解析

Valgrind 3.4.0 を用いてエラーの無いことを検証済み。
	
# バランス解析

各関数で実行される命令数については、ValgrindのCachegrindを利用して検証しgccのO0条件下でバランスしていることが示されています。

# 統計情報

Lines:
~~~
Lines  Blank  Cmnts  Source     AESL     
=====  =====  =====  =====  ==========  =======================================
  469     66    170    251       627.5  core_list_join.c  (C)
  330     18     54    268       670.0  core_main.c  (C)
  256     32     80    146       365.0  core_matrix.c  (C)
  240     16     51    186       465.0  core_state.c  (C)
  165     11     20    134       335.0  core_util.c  (C)
  150     23     36     98       245.0  coremark.h  (C)
 1610    166    411   1083      2707.5  ----- Benchmark -----  (6 files)
  293     15     74    212       530.0  linux/core_portme.c  (C)
  235     30    104    104       260.0  linux/core_portme.h  (C)
  528     45    178    316       790.0  ----- Porting -----  (2 files)
 
* 参考: Dhrystoneの場合
Lines  Blank  Cmnts  Source     AESL     
=====  =====  =====  =====  ==========  =======================================
  311     15    242     54       135.0  dhry.h  (C)
  789    132    119    553      1382.5  dhry_1.c  (C)
  186     26     68    107       267.5  dhry_2.c  (C)
 1286    173    429    714      1785.0  ----- C -----  (3 files)
~~~

# クレジット
Many thanks to all of the individuals who helped with the development or testing of CoreMark including (Sorted by company name; note that company names may no longer be accurate as this was written in 2009).
* Alan Anderson, ADI
* Adhikary Rajiv, ADI
* Elena Stohr, ARM
* Ian Rickards, ARM
* Andrew Pickard, ARM
* Trent Parker, CAVIUM
* Shay Gal-On, EEMBC
* Markus Levy, EEMBC
* Peter Torelli, EEMBC
* Ron Olson, IBM
* Eyal Barzilay, MIPS
* Jens Eltze, NEC
* Hirohiko Ono, NEC
* Ulrich Drees, NEC
* Frank Roscheda, NEC
* Rob Cosaro, NXP
* Shumpei Kawasaki, RENESAS

# 権利関係
本コードの権利関係についてはリポジトリ内のLICENSE.mdを参照してください。

# Copyright
Copyright © 2009 EEMBC All rights reserved. 
CoreMark is a trademark of EEMBC and EEMBC is a registered trademark of the Embedded Microprocessor Benchmark Consortium.

